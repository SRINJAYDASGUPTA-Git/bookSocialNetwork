/* tslint:disable */
/* eslint-disable */
/**
 * Book Network API
 * API for managing books and feedbacks
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dasguptasrinjay2004@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Authenticate200Response
 */
export interface Authenticate200Response {
    /**
     * 
     * @type {string}
     * @memberof Authenticate200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface AuthenticateRequest
 */
export interface AuthenticateRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticateRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationRequest
 */
export interface AuthenticationRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface BookRequest
 */
export interface BookRequest {
    /**
     * 
     * @type {number}
     * @memberof BookRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'isbn': string;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'synopsis': string;
    /**
     * 
     * @type {boolean}
     * @memberof BookRequest
     */
    'shareable'?: boolean;
}
/**
 * 
 * @export
 * @interface BookResponse
 */
export interface BookResponse {
    /**
     * 
     * @type {number}
     * @memberof BookResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'isbn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'synopsis'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'cover'?: string;
    /**
     * 
     * @type {number}
     * @memberof BookResponse
     */
    'rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BookResponse
     */
    'archived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BookResponse
     */
    'shareable'?: boolean;
}
/**
 * 
 * @export
 * @interface BorrowedBookResponse
 */
export interface BorrowedBookResponse {
    /**
     * 
     * @type {number}
     * @memberof BorrowedBookResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BorrowedBookResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BorrowedBookResponse
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof BorrowedBookResponse
     */
    'isbn'?: string;
    /**
     * 
     * @type {number}
     * @memberof BorrowedBookResponse
     */
    'rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BorrowedBookResponse
     */
    'returned'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BorrowedBookResponse
     */
    'returnApproved'?: boolean;
}
/**
 * 
 * @export
 * @interface FeedbackRequest
 */
export interface FeedbackRequest {
    /**
     * 
     * @type {number}
     * @memberof FeedbackRequest
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedbackRequest
     */
    'comment': string;
    /**
     * 
     * @type {number}
     * @memberof FeedbackRequest
     */
    'bookId': number;
}
/**
 * 
 * @export
 * @interface FeedbackResponse
 */
export interface FeedbackResponse {
    /**
     * 
     * @type {number}
     * @memberof FeedbackResponse
     */
    'note'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedbackResponse
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FeedbackResponse
     */
    'ownFeedback'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllBooks200Response
 */
export interface FindAllBooks200Response {
    /**
     * 
     * @type {Array<FindAllBooks200ResponseContentInner>}
     * @memberof FindAllBooks200Response
     */
    'content'?: Array<FindAllBooks200ResponseContentInner>;
    /**
     * 
     * @type {number}
     * @memberof FindAllBooks200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllBooks200Response
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllBooks200Response
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllBooks200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllBooks200Response
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllBooks200Response
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllBooks200ResponseContentInner
 */
export interface FindAllBooks200ResponseContentInner {
    /**
     * 
     * @type {number}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'isbn'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'synopsis'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'cover'?: string;
    /**
     * 
     * @type {number}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'archived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllBooks200ResponseContentInner
     */
    'shareable'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllFeedbacksByBook200Response
 */
export interface FindAllFeedbacksByBook200Response {
    /**
     * 
     * @type {Array<FindAllFeedbacksByBook200ResponseContentInner>}
     * @memberof FindAllFeedbacksByBook200Response
     */
    'content'?: Array<FindAllFeedbacksByBook200ResponseContentInner>;
    /**
     * 
     * @type {number}
     * @memberof FindAllFeedbacksByBook200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllFeedbacksByBook200Response
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllFeedbacksByBook200Response
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllFeedbacksByBook200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllFeedbacksByBook200Response
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllFeedbacksByBook200Response
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllFeedbacksByBook200ResponseContentInner
 */
export interface FindAllFeedbacksByBook200ResponseContentInner {
    /**
     * 
     * @type {number}
     * @memberof FindAllFeedbacksByBook200ResponseContentInner
     */
    'note'?: number;
    /**
     * 
     * @type {string}
     * @memberof FindAllFeedbacksByBook200ResponseContentInner
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllFeedbacksByBook200ResponseContentInner
     */
    'ownFeedback'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllReturnedBooks200Response
 */
export interface FindAllReturnedBooks200Response {
    /**
     * 
     * @type {Array<FindAllReturnedBooks200ResponseContentInner>}
     * @memberof FindAllReturnedBooks200Response
     */
    'content'?: Array<FindAllReturnedBooks200ResponseContentInner>;
    /**
     * 
     * @type {number}
     * @memberof FindAllReturnedBooks200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllReturnedBooks200Response
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllReturnedBooks200Response
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindAllReturnedBooks200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllReturnedBooks200Response
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllReturnedBooks200Response
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAllReturnedBooks200ResponseContentInner
 */
export interface FindAllReturnedBooks200ResponseContentInner {
    /**
     * 
     * @type {number}
     * @memberof FindAllReturnedBooks200ResponseContentInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FindAllReturnedBooks200ResponseContentInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllReturnedBooks200ResponseContentInner
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindAllReturnedBooks200ResponseContentInner
     */
    'isbn'?: string;
    /**
     * 
     * @type {number}
     * @memberof FindAllReturnedBooks200ResponseContentInner
     */
    'rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllReturnedBooks200ResponseContentInner
     */
    'returned'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FindAllReturnedBooks200ResponseContentInner
     */
    'returnApproved'?: boolean;
}
/**
 * 
 * @export
 * @interface PageResponseBookResponse
 */
export interface PageResponseBookResponse {
    /**
     * 
     * @type {Array<FindAllBooks200ResponseContentInner>}
     * @memberof PageResponseBookResponse
     */
    'content'?: Array<FindAllBooks200ResponseContentInner>;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseBookResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseBookResponse
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface PageResponseBorrowedBookResponse
 */
export interface PageResponseBorrowedBookResponse {
    /**
     * 
     * @type {Array<FindAllReturnedBooks200ResponseContentInner>}
     * @memberof PageResponseBorrowedBookResponse
     */
    'content'?: Array<FindAllReturnedBooks200ResponseContentInner>;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBorrowedBookResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBorrowedBookResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBorrowedBookResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBorrowedBookResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseBorrowedBookResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseBorrowedBookResponse
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface PageResponseFeedbackResponse
 */
export interface PageResponseFeedbackResponse {
    /**
     * 
     * @type {Array<FindAllFeedbacksByBook200ResponseContentInner>}
     * @memberof PageResponseFeedbackResponse
     */
    'content'?: Array<FindAllFeedbacksByBook200ResponseContentInner>;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseFeedbackResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseFeedbackResponse
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RegistrationRequest
 */
export interface RegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface SaveBookRequest
 */
export interface SaveBookRequest {
    /**
     * 
     * @type {number}
     * @memberof SaveBookRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SaveBookRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SaveBookRequest
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof SaveBookRequest
     */
    'isbn': string;
    /**
     * 
     * @type {string}
     * @memberof SaveBookRequest
     */
    'synopsis': string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveBookRequest
     */
    'shareable'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveFeedbackRequest
 */
export interface SaveFeedbackRequest {
    /**
     * 
     * @type {number}
     * @memberof SaveFeedbackRequest
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof SaveFeedbackRequest
     */
    'comment': string;
    /**
     * 
     * @type {number}
     * @memberof SaveFeedbackRequest
     */
    'bookId': number;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthenticateRequest} authenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticateRequest: AuthenticateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateRequest' is not null or undefined
            assertParamExists('authenticate', 'authenticateRequest', authenticateRequest)
            const localVarPath = `/auth/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('confirm', 'token', token)
            const localVarPath = `/auth/activate-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthenticateRequest} authenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticateRequest: AuthenticateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authenticate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authenticate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.confirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthenticateRequest} authenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticateRequest: AuthenticateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Authenticate200Response> {
            return localVarFp.authenticate(authenticateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm(token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirm(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {AuthenticateRequest} authenticateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(authenticateRequest: AuthenticateRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticate(authenticateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public confirm(token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).confirm(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookApi - axios parameter creator
 * @export
 */
export const BookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveReturnBorrowedBook: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('approveReturnBorrowedBook', 'bookId', bookId)
            const localVarPath = `/books/borrow/return/approve/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        borrowBook: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('borrowBook', 'bookId', bookId)
            const localVarPath = `/books/borrow/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooks: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooksByOwner: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books/owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBorrowedBooks: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books/borrowed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllReturnedBooks: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books/returned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBookById: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('findBookById', 'bookId', bookId)
            const localVarPath = `/books/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnBook: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('returnBook', 'bookId', bookId)
            const localVarPath = `/books/borrow/return/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveBookRequest} saveBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBook: async (saveBookRequest: SaveBookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveBookRequest' is not null or undefined
            assertParamExists('saveBook', 'saveBookRequest', saveBookRequest)
            const localVarPath = `/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveBookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArchivedStatus: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('updateArchivedStatus', 'bookId', bookId)
            const localVarPath = `/books/archive/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareableStatus: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('updateShareableStatus', 'bookId', bookId)
            const localVarPath = `/books/shareable/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} bookId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBookCoverPicture: async (bookId: number, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('uploadBookCoverPicture', 'bookId', bookId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadBookCoverPicture', 'file', file)
            const localVarPath = `/books/cover/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookApi - functional programming interface
 * @export
 */
export const BookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveReturnBorrowedBook(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveReturnBorrowedBook(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.approveReturnBorrowedBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async borrowBook(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.borrowBook(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.borrowBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAllBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllBooks(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findAllBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllBooksByOwner(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAllBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllBooksByOwner(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findAllBooksByOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllBorrowedBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAllReturnedBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllBorrowedBooks(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findAllBorrowedBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllReturnedBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAllReturnedBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllReturnedBooks(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findAllReturnedBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBookById(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAllBooks200ResponseContentInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBookById(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findBookById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnBook(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnBook(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.returnBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SaveBookRequest} saveBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveBook(saveBookRequest: SaveBookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveBook(saveBookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.saveBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArchivedStatus(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArchivedStatus(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.updateArchivedStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareableStatus(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareableStatus(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.updateShareableStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} bookId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadBookCoverPicture(bookId: number, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadBookCoverPicture(bookId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.uploadBookCoverPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookApi - factory interface
 * @export
 */
export const BookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookApiFp(configuration)
    return {
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveReturnBorrowedBook(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.approveReturnBorrowedBook(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        borrowBook(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.borrowBook(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<FindAllBooks200Response> {
            return localVarFp.findAllBooks(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooksByOwner(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<FindAllBooks200Response> {
            return localVarFp.findAllBooksByOwner(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBorrowedBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<FindAllReturnedBooks200Response> {
            return localVarFp.findAllBorrowedBooks(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllReturnedBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<FindAllReturnedBooks200Response> {
            return localVarFp.findAllReturnedBooks(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBookById(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<FindAllBooks200ResponseContentInner> {
            return localVarFp.findBookById(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnBook(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.returnBook(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveBookRequest} saveBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBook(saveBookRequest: SaveBookRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.saveBook(saveBookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArchivedStatus(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.updateArchivedStatus(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareableStatus(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.updateShareableStatus(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} bookId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBookCoverPicture(bookId: number, file: File, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.uploadBookCoverPicture(bookId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookApi - object-oriented interface
 * @export
 * @class BookApi
 * @extends {BaseAPI}
 */
export class BookApi extends BaseAPI {
    /**
     * 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public approveReturnBorrowedBook(bookId: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).approveReturnBorrowedBook(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public borrowBook(bookId: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).borrowBook(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findAllBooks(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findAllBooks(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findAllBooksByOwner(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findAllBooksByOwner(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findAllBorrowedBooks(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findAllBorrowedBooks(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findAllReturnedBooks(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findAllReturnedBooks(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findBookById(bookId: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findBookById(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public returnBook(bookId: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).returnBook(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveBookRequest} saveBookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public saveBook(saveBookRequest: SaveBookRequest, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).saveBook(saveBookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public updateArchivedStatus(bookId: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).updateArchivedStatus(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public updateShareableStatus(bookId: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).updateShareableStatus(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} bookId 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public uploadBookCoverPicture(bookId: number, file: File, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).uploadBookCoverPicture(bookId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedbacksApi - axios parameter creator
 * @export
 */
export const FeedbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} bookId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllFeedbacksByBook: async (bookId: number, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('findAllFeedbacksByBook', 'bookId', bookId)
            const localVarPath = `/feedbacks/book/{book-id}`
                .replace(`{${"book-id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveFeedbackRequest} saveFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFeedback: async (saveFeedbackRequest: SaveFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveFeedbackRequest' is not null or undefined
            assertParamExists('saveFeedback', 'saveFeedbackRequest', saveFeedbackRequest)
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbacksApi - functional programming interface
 * @export
 */
export const FeedbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} bookId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllFeedbacksByBook(bookId: number, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAllFeedbacksByBook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllFeedbacksByBook(bookId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedbacksApi.findAllFeedbacksByBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SaveFeedbackRequest} saveFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFeedback(saveFeedbackRequest: SaveFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFeedback(saveFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedbacksApi.saveFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedbacksApi - factory interface
 * @export
 */
export const FeedbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbacksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} bookId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllFeedbacksByBook(bookId: number, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<FindAllFeedbacksByBook200Response> {
            return localVarFp.findAllFeedbacksByBook(bookId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveFeedbackRequest} saveFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFeedback(saveFeedbackRequest: SaveFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.saveFeedback(saveFeedbackRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedbacksApi - object-oriented interface
 * @export
 * @class FeedbacksApi
 * @extends {BaseAPI}
 */
export class FeedbacksApi extends BaseAPI {
    /**
     * 
     * @param {number} bookId 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbacksApi
     */
    public findAllFeedbacksByBook(bookId: number, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return FeedbacksApiFp(this.configuration).findAllFeedbacksByBook(bookId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveFeedbackRequest} saveFeedbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbacksApi
     */
    public saveFeedback(saveFeedbackRequest: SaveFeedbackRequest, options?: RawAxiosRequestConfig) {
        return FeedbacksApiFp(this.configuration).saveFeedback(saveFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



